# -*- coding: utf-8 -*-
"""
/***************************************************************************
 direccGeoRef
                             A QGIS plugin
 georeferenciar domicilios mediante GeoRef
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
 Y asistencia de https://www.perplexity.ai/
                          -------------------
      begin                : 2025-09-09
      copyright            : (C) 2025 by jlmw78
      email                : jlmw78@jlmw78.jlmw78
 ***************************************************************************/
"""

import os.path
import csv
import json
import requests
import time
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject, QThread, pyqtSignal, Qt
from qgis.PyQt.QtGui import QIcon, QStandardItemModel, QStandardItem, QBrush, QColor
from qgis.PyQt.QtWidgets import (
    QAction,
    QDialog,
    QLabel,
    QVBoxLayout,
    QProgressBar,
    QApplication,
    QStyledItemDelegate,
    QFileDialog,
)
from qgis.core import (
    QgsVectorLayer,
    QgsFeature,
    QgsGeometry,
    QgsField,
    QgsFields,
    QgsProject,
    QgsVectorFileWriter,
    QgsPointXY,
)
from PyQt5.QtCore import QVariant
from .resources import *
from .direcciones_2_GeoRef_dialog import direccGeoRefDialog

# Clase para definir el color de fondo y texto según la observación en la tabla (columna 11)
class ObservacionesDelegate(QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super().initStyleOption(option, index)
        if index.column() == 11:
            valor = index.data()
            color_map = {
                'a descartar': QColor(255, 0, 0),
                'posible': QColor(0, 255, 0),
                'No encontrados': QColor(255, 165, 0),
                'a evaluar': QColor(255, 255, 0),
                'evaluar-calle si-altura no': QColor(135, 206, 250),
            }
            color = color_map.get(valor, None)
            if color:
                option.backgroundBrush = QBrush(color)
                option.palette.setColor(option.palette.Text, Qt.black)

# Clase que realiza la lectura y consulta a la API en segundo plano (hilo separado)
class Worker(QObject):
    finished = pyqtSignal(float)
    error = pyqtSignal(str)
    json_generated = pyqtSignal(str)
    api_response = pyqtSignal(str)

# Recibe ruta CSV y nombres de campos a usar
    def __init__(self, ruta_csv, campos):
        super().__init__()
        self.ruta_csv = ruta_csv
        self.campos = campos
        self.lista_original = []

# Lee CSV, crea JSON de direcciones, envía POST a API GeoRef, emite señales con resultados o errores
    def run(self):
        start_time = time.time()
        try:
            lista_direcciones = []
            self.lista_original = []
            with open(self.ruta_csv, 'r', encoding='utf-8') as f:
                lector = csv.DictReader(f)
                for fila in lector:
                    id_val = fila.get(self.campos['id'], "")
                    direcc_orig_val = fila.get(self.campos['direccion'], "")
                    elemento = {
                        "max": 10,
                        "aplanar": "true",
                        "desplazar": "true",
                        "campos": "estandar",
                        "provincia": fila.get(self.campos['provincia'], ""),
                        "departamento": fila.get(self.campos['departamento'], ""),
                        "localidad": fila.get(self.campos['localidad'], ""),
                        "direccion": direcc_orig_val
                    }
                    lista_direcciones.append(elemento)
                    self.lista_original.append({
                        "id": id_val,
                        "direcc_orig": direcc_orig_val,
                        "provincia": fila.get(self.campos['provincia'], ""),
                        "departamento": fila.get(self.campos['departamento'], ""),
                        "localidad": fila.get(self.campos['localidad'], "")
                    })
            data_json = {"direcciones": lista_direcciones}
            texto_json = json.dumps(data_json, indent=2, ensure_ascii=False)
            self.json_generated.emit(texto_json)
            url_api = "https://apis.datos.gob.ar/georef/api/v2.0/direcciones"
            response = requests.post(
                url_api,
                headers={"Content-Type": "application/json"},
                json=data_json
            )
            self.api_response.emit(response.text)
        except Exception as e:
            self.error.emit(str(e))
            return
        end_time = time.time()
        duracion = end_time - start_time
        self.finished.emit(duracion)


class direccGeoRef:
# Inicializa plugin, carga traducciones y variables
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir, 'i18n', f'direccGeoRef_{locale}.qm')
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)
        self.actions = []
        self.menu = self.tr('&georefernciar con GeoRef')
        self.first_start = None
        self.lista_original = []

# Traduce mensajes para interfaz
    def tr(self, message):
        return QCoreApplication.translate('direccGeoRef', message)

# Crea un item de tabla no editable para mostrar datos
    def crear_item_no_editable(self, texto):
        item = QStandardItem(texto)
        item.setFlags(item.flags() & ~Qt.ItemIsEditable)
        return item

# Agrega acciones en la barra de herramientas y menú de QGIS para activar el plugin
    def add_action(self,
                   icon_path,
                   text,
                   callback,
                   enabled_flag=True,
                   add_to_menu=True,
                   add_to_toolbar=True,
                   status_tip=None,
                   whats_this=None,
                   parent=None):
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None:
            action.setStatusTip(status_tip)
        if whats_this is not None:
            action.setWhatsThis(whats_this)
        if add_to_toolbar:
            self.iface.addToolBarIcon(action)
        if add_to_menu:
            self.iface.addPluginToMenu(self.menu, action)
        self.actions.append(action)
        return action

# Configura los elementos GUI al iniciar el plugin: botón, icono, menú
    def initGui(self):
        icon_path = ':/plugins/direcciones_2_GeoRef/icon.png'
        self.add_action(icon_path,
                        text=self.tr('georeferenciar mediante GeoRef'),
                        callback=self.run,
                        parent=self.iface.mainWindow())
        self.first_start = True

# Limpia menú y toolbar al descargar el plugin
    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(self.tr('&georefernciar con GeoRef'), action)
            self.iface.removeToolBarIcon(action)

# Controla la apertura y configuración del diálogo principal
    def run(self):
        if self.first_start:
            self.first_start = False
            self.dlg = direccGeoRefDialog()
            self.dlg.mQgsFileWidget.setFilter('*.csv')
            self.dlg.mQgsFileWidget.fileChanged.connect(self.cargar_campos_csv)
            self.dlg.pushButton.clicked.connect(self.generar_json_desde_csv)
            # Asignar funciones a botones de exportacion/filtrado
            self.dlg.pushButton_2.clicked.connect(self.exportar_tabla_completa)
            self.dlg.pushButton_3.clicked.connect(self.exportar_filtrados_3)
            self.dlg.pushButton_4.clicked.connect(self.exportar_filtrados_4)
            self.dlg.pushButton_5.clicked.connect(self.exportar_filtrados_5)
            self.dlg.pushButton_6.clicked.connect(self.exportar_posible_geojson)
        self.dlg.show()
        self.dlg.exec_()

# Lee la cabecera del CSV seleccionado para cargar nombres de campos en combos para asignación
    def cargar_campos_csv(self, file_path):
        if not file_path:
            return
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                sample = f.read(1024)  # Lee una muestra para detectar
                f.seek(0)
                dialect = csv.Sniffer().sniff(sample, delimiters=',;\t')
                f.seek(0)
                lector = csv.reader(f, dialect)
                nombres_campos = next(lector)
        except Exception as e:
            self.iface.messageBar().pushWarning("Error CSV", f"No se pudo leer el archivo: {e}")
            return
        combo_boxes = [
            self.dlg.comboBox_1,
            self.dlg.comboBox_2,
            self.dlg.comboBox_3,
            self.dlg.comboBox_4,
            self.dlg.comboBox_5,
        ]
        for combo in combo_boxes:
            combo.clear()
            combo.addItems(nombres_campos)

# Muestra un diálogo modal con barra de progreso indefinida para indicar espera en procesos
    def mostrar_dialogo_espera(self, mensaje="Procesando, por favor espere..."):
        dialogo = QDialog(self.dlg)
        dialogo.setModal(True)
        dialogo.setWindowTitle("Espera")
        layout = QVBoxLayout()
        label = QLabel(mensaje)
        layout.addWidget(label)
        progress_bar = QProgressBar()
        progress_bar.setRange(0, 0)
        layout.addWidget(progress_bar)
        dialogo.setLayout(layout)
        dialogo.resize(300, 100)
        dialogo.show()
        QApplication.processEvents()
        return dialogo

# Inicia hilo trabajador para leer CSV, generar JSON y consultar la API en segundo plano
    def generar_json_desde_csv(self):
        ruta_csv = self.dlg.mQgsFileWidget.filePath()
        if not ruta_csv:
            self.iface.messageBar().pushWarning("Archivo no seleccionado", "Seleccione un archivo CSV primero.")
            return
        campos = {
            'id': self.dlg.comboBox_1.currentText(),
            'provincia': self.dlg.comboBox_2.currentText(),
            'departamento': self.dlg.comboBox_3.currentText(),
            'localidad': self.dlg.comboBox_4.currentText(),
            'direccion': self.dlg.comboBox_5.currentText()
        }
        self.dialogo_espera = self.mostrar_dialogo_espera()
        self.thread = QThread()
        self.worker = Worker(ruta_csv, campos)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.proceso_terminado)
        self.worker.finished.connect(self.thread.quit)
        self.worker.error.connect(self.proceso_error)
        self.worker.json_generated.connect(self.actualizar_json)
        self.worker.api_response.connect(self.manejar_respuesta_api)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.thread.start()

# Procesa la respuesta de la API para actualizar tabla con resultados
    def manejar_respuesta_api(self, texto_api):
        self.actualizar_resultados(texto_api)
        self.lista_original = self.worker.lista_original
        self.cargar_json_a_tabla(texto_api)

# Oculta diálogo de espera e informa tiempo de proceso
    def proceso_terminado(self, duracion):
        self.dialogo_espera.accept()
        self.dlg.label_8.setText(f"Tiempo empleado: {duracion:.2f} segundos")
        self.iface.messageBar().pushMessage(f"Proceso completado en {duracion:.2f} segundos", level=0, duration=5)

# Oculta diálogo de espera e informa error ocurrido
    def proceso_error(self, mensaje):
        self.dialogo_espera.accept()
        self.iface.messageBar().pushWarning("Error", mensaje)

# Muestra el JSON generado desde CSV en la interfaz
    def actualizar_json(self, texto_json):
        self.dlg.plainTextEdit_1.setPlainText(texto_json)

# Muestra la respuesta cruda recibida de la API en la interfaz
    def actualizar_resultados(self, texto_api):
        self.dlg.plainTextEdit_2.setPlainText(texto_api)

# Genera línea de datos para la tabla, sin permitir edición
    def crear_items_fila_no_editable(self, valores):
        return [self.crear_item_no_editable(str(v)) for v in valores]

# Carga y procesa JSON de la API, llenando la tabla con la info estructurada y las observaciones
    def cargar_json_a_tabla(self, texto_api):
        try:
            data = json.loads(texto_api)
        except Exception as e:
            self.iface.messageBar().pushWarning("Error JSON", f"No se pudo cargar el JSON en tabla: {e}")
            return

        modelo = QStandardItemModel()
        encabezados = ["Registro CSV", "id_csv", "direcc_csv", "Cantidad", "Provincia", "Departamento", "Localidad",
                      "calle_id", "Dirección", "Latitud", "Longitud", "Observaciones"]
        modelo.setHorizontalHeaderLabels(encabezados)

        resultados = data.get("resultados", [])
        for idx, resultado in enumerate(resultados):
            direcciones = resultado.get("direcciones", [])
            cantidad = resultado.get("cantidad", 0)
            numero_registro = idx + 1

            try:
                registro_origen = self.lista_original[idx]
            except (IndexError, AttributeError):
                registro_origen = {"id": "", "direcc_orig": "", "provincia": "", "departamento": "", "localidad": ""}

            id_csv = registro_origen.get("id", "")
            direcc_csv = registro_origen.get("direcc_orig", "")

            if not direcciones:
                fila_valores = [
                    str(numero_registro),
                    id_csv,
                    direcc_csv,
                    str(cantidad),
                    registro_origen.get("provincia", ""),
                    registro_origen.get("departamento", ""),
                    registro_origen.get("localidad", ""),
                    "",
                    "",
                    "",
                    "",
                    ""  # Observaciones vacio por ahora
                ]
                modelo.appendRow(self.crear_items_fila_no_editable(fila_valores))
            else:
                for direccion in direcciones:
                    fila_valores = [
                        str(numero_registro),
                        id_csv,
                        direcc_csv,
                        str(cantidad),
                        direccion.get("provincia_nombre", ""),
                        direccion.get("departamento_nombre", ""),
                        direccion.get("localidad_censal_nombre", ""),
                        direccion.get("calle_id", ""),
                        f"{direccion.get('calle_nombre', '')} {direccion.get('altura_valor', '')}".strip(),
                        str(direccion.get("ubicacion_lat", "")),
                        str(direccion.get("ubicacion_lon", "")),
                        ""  # Observaciones vacio por ahora
                    ]
                    modelo.appendRow(self.crear_items_fila_no_editable(fila_valores))

        self.dlg.tableView_1.setModel(modelo)
        self.dlg.tableView_1.setItemDelegateForColumn(11, ObservacionesDelegate())
        self.dlg.tableView_1.resizeColumnsToContents()
        self.observaciones_cantidad_0y1(modelo)
        self.observaciones_cantidad_mayor_a_1(modelo)

# Asigna observaciones para filas con 0 o 1 resultado según reglas definidas (e.g. "No encontrados")
    def observaciones_cantidad_0y1(self, modelo):
        filas = modelo.rowCount()
        for fila in range(filas):
            cantidad_item = modelo.item(fila, 3)
            cantidad = 0
            if cantidad_item is not None and cantidad_item.text().isdigit():
                cantidad = int(cantidad_item.text())
            calle_id_item = modelo.item(fila, 7)
            calle_id = calle_id_item.text() if calle_id_item is not None else ""
            latitud_item = modelo.item(fila, 9)
            latitud_text = latitud_item.text() if latitud_item is not None else ""
            latitud_valida = bool(latitud_text and latitud_text.lower() != "none")
            observacion = ""
            if cantidad == 0:
                observacion = "No encontrados"
            elif cantidad == 1:
                if calle_id and not latitud_valida:
                    observacion = "calle si - altura no"
                else:
                    observacion = "posible"
            modelo.setItem(fila, 11, self.crear_item_no_editable(observacion))

# Asigna observaciones para filas con más de 1 resultado, estableciendo prioridad para posible, evaluar o descartar
    def observaciones_cantidad_mayor_a_1(self, modelo):
        from collections import defaultdict
        grupos = defaultdict(list)
        filas = modelo.rowCount()

        def es_coordenada_valida(valor):
            if valor is None:
                return False
            try:
                val_float = float(valor)
                return val_float != 0 and not (val_float != val_float)
            except:
                return False

        for fila in range(filas):
            registro_csv_item = modelo.item(fila, 0)
            cantidad_item = modelo.item(fila, 3)
            if registro_csv_item and cantidad_item and cantidad_item.text().isdigit():
                cantidad = int(cantidad_item.text())
                if cantidad > 1:
                    clave = registro_csv_item.text()
                    grupos[clave].append(fila)

        for clave, indices_fila in grupos.items():
            calle_validos = []
            lat_validados = []
            for idx in indices_fila:
                calle_id = modelo.item(idx, 7).text() if modelo.item(idx, 7) else ""
                latitud = modelo.item(idx, 9).text() if modelo.item(idx, 9) else ""
                if calle_id != "":
                    calle_validos.append(idx)
                if es_coordenada_valida(latitud):
                    lat_validados.append(idx)
            if len(calle_validos) == len(indices_fila) and len(lat_validados) == 0:
                for idx in indices_fila:
                    modelo.setItem(idx, 11, self.crear_item_no_editable("evaluar-calle si-altura no"))
                continue
            registros_validos = list(set(calle_validos).intersection(lat_validados))
            if len(registros_validos) == 1:
                for idx in indices_fila:
                    if idx == registros_validos[0]:
                        modelo.setItem(idx, 11, self.crear_item_no_editable("posible"))
                    else:
                        modelo.setItem(idx, 11, self.crear_item_no_editable("a descartar"))
                continue
            if len(registros_validos) > 1:
                for idx in indices_fila:
                    if idx in registros_validos:
                        modelo.setItem(idx, 11, self.crear_item_no_editable("a evaluar"))
                    else:
                        modelo.setItem(idx, 11, self.crear_item_no_editable("a descartar"))
                continue

# Funciones para exportar datos (completo o filtrado por observaciones) a CSV
    # Añade extensión ".csv" al nombre de archivo si es necesario
    def asegurar_extension_csv(self, path):
        if not path.lower().endswith('.csv'):
            path += '.csv'
        return path

# Guarda los datos del modelo de tabla a archivo CSV, opcionalmente solo filas indicadas
    def guardar_modelo_csv(self, modelo, path, indices_filas=None):
        with open(path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            headers = [modelo.headerData(i, Qt.Horizontal) for i in range(modelo.columnCount())]
            writer.writerow(headers)
            filas = indices_filas if indices_filas is not None else range(modelo.rowCount())
            for row in filas:
                rowdata = []
                for col in range(modelo.columnCount()):
                    idx = modelo.index(row, col)
                    rowdata.append(str(modelo.data(idx)))
                writer.writerow(rowdata)

# Exporta toda la tabla al archivo CSV elegido por el usuario
    def exportar_tabla_completa(self):
        path, _ = QFileDialog.getSaveFileName(self.dlg, "Guardar CSV completo", "", "CSV (*.csv)")
        if path:
            path = self.asegurar_extension_csv(path)
        if not path:
            return
        modelo = self.dlg.tableView_1.model()
        self.guardar_modelo_csv(modelo, path)

# Exporta filas con ciertas observaciones filtradas
    def exportar_filtrados_con_observaciones(self, observaciones_filtrar, titulo_dialogo):
        modelo = self.dlg.tableView_1.model()
        filas_filtradas = []
        for row in range(modelo.rowCount()):
            idx_obs = modelo.index(row, 11)
            valor = modelo.data(idx_obs)
            if valor in observaciones_filtrar:
                filas_filtradas.append(row)
        if not filas_filtradas:
            self.iface.messageBar().pushWarning("Aviso", "No hay registros para exportar con esas observaciones")
            return
        path, _ = QFileDialog.getSaveFileName(self.dlg, titulo_dialogo, "", "CSV (*.csv)")
        if path:
            path = self.asegurar_extension_csv(path)
        if not path:
            return
        self.guardar_modelo_csv(modelo, path, filas_filtradas)

# Exporta registros para observaciones específicas: No encontrados y evaluaciones
    def exportar_filtrados_3(self):
        self.exportar_filtrados_con_observaciones(
            {'No encontrados', 'a evaluar', 'evaluar-calle si-altura no'},
            "Guardar registros No encontrados o Evaluar"
        )

# Exporta registros marcados como "a descartar"
    def exportar_filtrados_4(self):
        self.exportar_filtrados_con_observaciones({'a descartar'}, "Guardar registros a descartar")

# Exporta registros marcados como "posible"
    def exportar_filtrados_5(self):
        self.exportar_filtrados_con_observaciones({'posible'}, "Guardar registros Posibles")

# Genera una capa de puntos de QGIS con los registros "posible" y la guarda como GeoJSON
    def exportar_posible_geojson(self):
        modelo = self.dlg.tableView_1.model()
        fields = QgsFields()
        columnas = [modelo.headerData(i, Qt.Horizontal) for i in range(modelo.columnCount())]
        for col_name in columnas:
            fields.append(QgsField(col_name, QVariant.String))
        vl = QgsVectorLayer("Point?crs=EPSG:4326", "Posibles GeoRef", "memory")
        pr = vl.dataProvider()
        pr.addAttributes(fields)
        vl.updateFields()
        for row in range(modelo.rowCount()):
            idx_obs = modelo.index(row, 11)
            if modelo.data(idx_obs) == 'posible':
                feat = QgsFeature()
                attrs = []
                for col in range(modelo.columnCount()):
                    idx = modelo.index(row, col)
                    attrs.append(modelo.data(idx))
                feat.setAttributes(attrs)
                try:
                    lat = float(attrs[9])
                    lon = float(attrs[10])
                    feat.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(lon, lat)))
                except Exception:
                    feat.setGeometry(QgsGeometry())
                pr.addFeature(feat)
        vl.updateExtents()
        path, _ = QFileDialog.getSaveFileName(self.dlg, "Guardar GeoJSON", "", "GeoJSON (*.geojson *.json)")
        if path:
            path = self.asegurar_extension_csv(path)
        if path:
            error = QgsVectorFileWriter.writeAsVectorFormat(vl, path, "utf-8", vl.crs(), "GeoJSON")
            if error != QgsVectorFileWriter.NoError:
                self.iface.messageBar().pushWarning("Error", "Error guardando GeoJSON")
            else:
                self.iface.messageBar().pushMessage("GeoJSON guardado correctamente", level=0, duration=3)
        QgsProject.instance().addMapLayer(vl)
